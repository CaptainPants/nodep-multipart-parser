{
  "version": 3,
  "sources": ["../../../src/data/Data.ts"],
  "sourcesContent": ["import { blobToArrayBuffer, blobToString, expensiveCompativalBlobSourceToString, stringToArrayBuffer } from \"./internal\";\n\nexport type DataSource = string | ArrayBuffer | DataView | Blob;\n\nexport type BinaryResult<T extends Blob | DataView | ArrayBuffer> = { value: T; encoding: string | undefined };\n\n/**\n  * A generic container for data of either text or binsry format, allowing easy conversion to the desire format for processing. In modern browsers this is similar\n  * to the Response class.\n  * as some conversion methods are asynchronous.\n  * @param source The original source data to later be converted.\n  * @param sourceEncoding The encoding used on string data stored in binary format.\n  */\nexport class Data {\n    constructor(\n        public source: DataSource,\n        public sourceEncoding: string | undefined\n    ) {\n        if (!(typeof source === 'string' || source instanceof DataView || source instanceof ArrayBuffer || source instanceof Blob)) {\n            throw new TypeError(`Unexpected data type ${source}.`);\n        }\n    }\n\n    public string(): Promise<string> {\n        if (typeof this.source === 'string') {\n            return Promise.resolve(this.source);\n        }\n        else if (this.source instanceof Blob) {\n            return blobToString(this.source, this.sourceEncoding);\n        }\n        else {\n            if (TextDecoder) {\n                return Promise.resolve(new TextDecoder(this.sourceEncoding).decode(this.source));\n            }\n            else {\n                // Basically IE11 here\n                return expensiveCompativalBlobSourceToString(this.source, this.sourceEncoding);\n            }\n        }\n    }\n\n    public async arrayBuffer(): Promise<BinaryResult<ArrayBuffer>> {\n        if (this.source instanceof ArrayBuffer) {\n            return { value: this.source, encoding: this.sourceEncoding };\n        }\n        else if (this.source instanceof DataView) {\n            const res = new ArrayBuffer(this.source.byteLength);\n            new Uint8Array(res).set(new Uint8Array(this.source.buffer, this.source.byteOffset, this.source.byteLength));\n            return { value: res, encoding: this.sourceEncoding };\n        }\n        else if (this.source instanceof Blob) {\n            return { value: await blobToArrayBuffer(this.source), encoding: this.sourceEncoding };\n        }\n        else {\n            return { value: await stringToArrayBuffer(this.source), encoding: 'utf-8' };\n        }\n    }\n\n    public blob(): Promise<BinaryResult<Blob>> {\n        if (this.source instanceof Blob) {\n            return Promise.resolve({ value: this.source, encoding: this.sourceEncoding });\n        }\n        else if (typeof this.source === 'string') {\n            Promise.resolve({ value: new Blob([this.source]), encoding: 'utf-8' });\n        }\n        return Promise.resolve({ value: new Blob([this.source]), encoding: this.sourceEncoding });\n    }\n\n    public async dataView(): Promise<BinaryResult<DataView>> {\n        if (this.source instanceof ArrayBuffer) {\n            return { value: new DataView(this.source), encoding: this.sourceEncoding };\n        }\n        else if (this.source instanceof DataView) {\n            return { value: this.source, encoding: this.sourceEncoding };\n        }\n        else if (this.source instanceof Blob) {\n            return { value: new DataView(await blobToArrayBuffer(this.source)), encoding: this.sourceEncoding };\n        }\n        else {\n            return { value: new DataView(await stringToArrayBuffer(this.source)), encoding: 'utf-8' };\n        }\n    }\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,sBAA4G;AAarG,WAAW;AAAA,EACd,YACW,QACA,gBACT;AAFS;AACA;AAEP,QAAI,CAAE,QAAO,WAAW,YAAY,kBAAkB,YAAY,kBAAkB,eAAe,kBAAkB,OAAO;AACxH,YAAM,IAAI,UAAU,wBAAwB;AAAA;AAAA;AAAA,EAI7C,SAA0B;AAC7B,QAAI,OAAO,KAAK,WAAW,UAAU;AACjC,aAAO,QAAQ,QAAQ,KAAK;AAAA,eAEvB,KAAK,kBAAkB,MAAM;AAClC,aAAO,kCAAa,KAAK,QAAQ,KAAK;AAAA,WAErC;AACD,UAAI,aAAa;AACb,eAAO,QAAQ,QAAQ,IAAI,YAAY,KAAK,gBAAgB,OAAO,KAAK;AAAA,aAEvE;AAED,eAAO,2DAAsC,KAAK,QAAQ,KAAK;AAAA;AAAA;AAAA;AAAA,QAK9D,cAAkD;AAC3D,QAAI,KAAK,kBAAkB,aAAa;AACpC,aAAO,EAAE,OAAO,KAAK,QAAQ,UAAU,KAAK;AAAA,eAEvC,KAAK,kBAAkB,UAAU;AACtC,YAAM,MAAM,IAAI,YAAY,KAAK,OAAO;AACxC,UAAI,WAAW,KAAK,IAAI,IAAI,WAAW,KAAK,OAAO,QAAQ,KAAK,OAAO,YAAY,KAAK,OAAO;AAC/F,aAAO,EAAE,OAAO,KAAK,UAAU,KAAK;AAAA,eAE/B,KAAK,kBAAkB,MAAM;AAClC,aAAO,EAAE,OAAO,MAAM,uCAAkB,KAAK,SAAS,UAAU,KAAK;AAAA,WAEpE;AACD,aAAO,EAAE,OAAO,MAAM,yCAAoB,KAAK,SAAS,UAAU;AAAA;AAAA;AAAA,EAInE,OAAoC;AACvC,QAAI,KAAK,kBAAkB,MAAM;AAC7B,aAAO,QAAQ,QAAQ,EAAE,OAAO,KAAK,QAAQ,UAAU,KAAK;AAAA,eAEvD,OAAO,KAAK,WAAW,UAAU;AACtC,cAAQ,QAAQ,EAAE,OAAO,IAAI,KAAK,CAAC,KAAK,UAAU,UAAU;AAAA;AAEhE,WAAO,QAAQ,QAAQ,EAAE,OAAO,IAAI,KAAK,CAAC,KAAK,UAAU,UAAU,KAAK;AAAA;AAAA,QAG/D,WAA4C;AACrD,QAAI,KAAK,kBAAkB,aAAa;AACpC,aAAO,EAAE,OAAO,IAAI,SAAS,KAAK,SAAS,UAAU,KAAK;AAAA,eAErD,KAAK,kBAAkB,UAAU;AACtC,aAAO,EAAE,OAAO,KAAK,QAAQ,UAAU,KAAK;AAAA,eAEvC,KAAK,kBAAkB,MAAM;AAClC,aAAO,EAAE,OAAO,IAAI,SAAS,MAAM,uCAAkB,KAAK,UAAU,UAAU,KAAK;AAAA,WAElF;AACD,aAAO,EAAE,OAAO,IAAI,SAAS,MAAM,yCAAoB,KAAK,UAAU,UAAU;AAAA;AAAA;AAAA;",
  "names": []
}
