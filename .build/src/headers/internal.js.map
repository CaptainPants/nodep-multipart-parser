{
  "version": 3,
  "sources": ["../../../src/headers/internal.ts"],
  "sourcesContent": ["\n\n// refer https://datatracker.ietf.org/doc/html/rfc7231#section-3.1.1.5\n// > media-type = type \"/\" subtype *( OWS \";\" OWS parameter )\n// > parameter  = token \"=\" ( token / quoted-string )\n// https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.3\n// zero or more linear whitespace octets\n// > OWS            = ( SP / HTAB )\n// https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\n// > token          = 1*tchar\n// > tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n// >                / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n// >                / DIGIT / ALPHA\n// >                ; any VCHAR, except delimiters\n// > quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n// > qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text\n// > obs-text       = %x80-FF\n// > delimiter      => any of \"(),/:;<=>?@[\\]{}\n\nimport { ParseError } from \"../ParseError\";\n\nexport interface HeaderParserState {\n    index: number;\n    end: number;\n    string: string;\n}\n\nexport function isFinished(state: HeaderParserState) {\n    return state.index >= state.end;\n}\n\nexport function isAtCRLF(state: HeaderParserState) {\n    if (state.index + 1 > state.end) {\n        return false;\n    }\n\n    return state.string[state.index] == '\\r' && state.string[state.index + 1] == '\\n';\n}\n\nconst delimRegex = /^[\"(),/:;<=>?@[\\]{}]$/;\nexport function isDelimiter(char: string | undefined) {\n    if (!char) return false;\n    return Boolean(char.match(delimRegex));\n}\n\n/**\n  * \n  * > tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n  * >                / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n  * >                / DIGIT / ALPHA\n  * >                ; any VCHAR, except delimiters\n  */\nexport function isTCHAR(char: string | undefined) {\n    if (!char) return false;\n    return isVCHAR(char) && !isDelimiter(char);\n}\n\n/**\n  * Is a single character part of the visible subset of ASCII (33 -> 127)?\n  */\nexport function isVCHAR(char: string | undefined) {\n    if (!char) return false;\n    if (char.length != 1) throw new TypeError(`Expected a single character or undefined, found instead ${char}`);\n    const codepoint = char.codePointAt(0);\n    return codepoint !== undefined\n        && codepoint >= 33 && codepoint < 127;\n}\n\nexport function isSpace(char: string | undefined) {\n    if (char && char.length != 1) throw new TypeError(`Expected a single character or undefined, found instead ${char}`);\n    return char == ' ' || char == '\\t';\n}\n\n/**\n  * Consume any whitespace at the current index. Does nothing if the end has been reached.\n  */\nexport function consumeOptionalWhitespace(state: HeaderParserState) {\n    for (; ;) {\n        if (state.index >= state.end) {\n            return;\n        }\n\n        const current = state.string[state.index];\n        if (current !== '\\t' && current !== ' ') {\n            return;\n        }\n\n        // must have been whitespace, continue\n        ++state.index;\n    }\n}\n\nexport function readToNextLine(state: HeaderParserState) {\n    const startIndex = state.index;\n    let end: number | undefined;\n\n    for (; ;) {\n        if (isAtCRLF(state)) {\n            end = state.index;\n            state.index += 2;\n            break;\n        }\n        else if (isFinished(state)) {\n            end = state.index;\n            break;\n        }\n\n        ++state.index;\n    }\n\n    if (end === undefined) {\n        throw new ParseError(\"Unexpected.\");\n    }\n\n    return state.string.substring(startIndex, end);\n}\n\nexport function readToken(state: HeaderParserState) {\n    const token = readOptionalToken(state);\n    if (!token) {\n        if (isFinished(state)) {\n            throw new ParseError('Unexpected EOF, expected token.');\n        }\n        throw new ParseError(`Unexpected '${state.string[state.index]}', expected token.`);\n    }\n    return token;\n}\n\n/**\n  * Read a token, returning undefined if the current character is not a valid TCHAR or the state is finished.\n  */\nexport function readOptionalToken(state: HeaderParserState) {\n    if (state.index >= state.string.length) {\n        return undefined;\n    }\n\n    const parts: string[] = [];\n\n    for (; !isFinished(state); ++state.index) {\n        const char = state.string[state.index];\n\n        if (!isTCHAR(char)) {\n            break;\n        }\n\n        parts.push(char);\n    }\n\n    return parts.length == 0 ? undefined : parts.join('');\n}\n\n/*\n * Read a quoted string. Assumes that the current state is pointing to a double quote.\n * See 'quoted' in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\n */\nexport function readQuoted(state: HeaderParserState) {\n    // We are looking at the opening quote\n\n    if (state.string[state.index] != '\"') {\n        throw new ParseError(`Unexpected ${state.string[state.index]}, expected \".`);\n    }\n\n    // move past the quotation mark\n    ++state.index;\n\n    const res: string[] = [];\n\n    for (; ;) {\n        if (state.index >= state.end) {\n            break;\n        }\n\n        const current = state.string[state.index];\n\n        // See 'quoted-pair' in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\n        // A double quote is allowed if preceeded by a \\\n        if (current == '\"' && state.string[state.index - 1] != '\\\\') {\n            break;\n        }\n\n        res.push(current);\n\n        ++state.index;\n    }\n\n    if (state.index >= state.end) {\n        throw new ParseError(`Unexpected EOF, expecting '\"'.`);\n    }\n\n    const closeQuote = state.string[state.index];\n    if (closeQuote != '\"') {\n        throw new ParseError(`Unexpected '${closeQuote}', expecting '\"'.`);\n    }\n\n    // move past the end quotation mark\n    ++state.index;\n\n    const merged = res.join('');\n    // quoted pairs have a preceeding \\, e.g. \\\"\n    // Specifically replace \\\\ with \\ and \\\" with \", but also anything else preceeded by a \\\n    return merged.replace(/\\\\(.)/g, '$1');\n}\n\n\n/**\n  * Refer to 'parameter' in https://datatracker.ietf.org/doc/html/rfc7231#section-3.1.1.1\n  */\nexport function readOneParameter(state: HeaderParserState): { name: string, value: string } | undefined {\n    consumeOptionalWhitespace(state);\n\n    const parameterName = readOptionalToken(state);\n\n    if (!parameterName) {\n        if (isFinished(state)) {\n            return undefined;\n        }\n        else {\n            throw new ParseError(`Unexpected ${state.string[state.index]}, expecting a token.`);\n        }\n    }\n\n    // technically not allowed, but for tolerance sake\n    consumeOptionalWhitespace(state);\n\n    if (isFinished(state) || state.string[state.index] !== '=') {\n        throw new ParseError(`Unexpected ${state.string[state.index]}, expecting an equals sign.`);\n    }\n\n    // move past the =\n    ++state.index;\n\n    // technically not allowed, but for tolerance sake\n    consumeOptionalWhitespace(state);\n\n    if (isFinished(state)) {\n        throw new ParseError(`Unexpected EOF, expecting a token or quoted-string.`);\n    }\n\n    let value: string;\n    if (state.string[state.index] === '\"') {\n        value = readQuoted(state);\n    }\n    else {\n        value = readToken(state);\n    }\n\n    return { name: parameterName, value: value };\n}\n\nexport type Parameters = { name: string; value: string }[];\n\nexport function processParametersIfPresent(state: HeaderParserState): Parameters {\n    const res: Parameters = [];\n\n    for (; ;) {\n        // sitting just after the previous parameter\n        consumeOptionalWhitespace(state);\n\n        if (isFinished(state)) {\n            break;\n        }\n\n        // there should be a ; between parameters\n        const semicolon = state.string[state.index];\n        if (semicolon !== ';') {\n            throw new ParseError(`Unexpected '${semicolon}' when expecting a semi-colon ';'.`);\n        }\n\n        // move past semicolon\n        ++state.index;\n\n        // then a parameter\n        const parameter = readOneParameter(state);\n\n        if (!parameter) {\n            if (!isFinished(state)) {\n                throw new ParseError(`Unexpected '${state.string[state.index]}' when expecting parameter or EOF.`);\n            }\n            break; // technically a violation of the standard but we'll allow it\n        }\n\n        res.push(parameter);\n    }\n\n    return res;\n}\n"],
  "mappings": "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",
  "names": []
}
