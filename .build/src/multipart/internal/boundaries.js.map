{
  "version": 3,
  "sources": ["../../../../src/multipart/internal/boundaries.ts"],
  "sourcesContent": ["import { isCRLF, isDoubleHyphen } from \".\";\nimport { ParseError } from \"../..\";\n\nexport interface Boundary {\n    start: number;\n    end: number;\n    length: number;\n    isLast: boolean;\n}\n\n/**\n  * https://www.rfc-editor.org/rfc/rfc2046#section-5.1.1\n  * > The Content-Type field for multipart entities requires one parameter,\n  * > \"boundary\". The boundary delimiter line is then defined as a line\n  * > consisting entirely of two hyphen characters (\"-\", decimal value 45)\n  * > followed by the boundary parameter value from the Content-Type header\n  * > field, optional linear whitespace, and a terminating CRLF.\n  */\nexport function findBoundaryOffsets(boundary: number[], data: DataView): Boundary[] {\n    if (boundary.length <= 0) {\n        throw new ParseError(`Boundary length of 0 is not supported.`);\n    }\n\n    const res: Boundary[] = [];\n\n    // TODO: if we hit the end and we're not on a last boundary,\n    // or if we hit a last boundary and its not the end..\n    for (let i = 0; i < data.byteLength;) {\n        const matched = matchBoundary(boundary, data, i);\n\n        if (matched) {\n            res.push(matched);\n            i += matched.length;\n        }\n        else {\n            ++i;\n        }\n    }\n\n    return res;\n}\n\nexport function matchBoundary(boundary: number[], data: DataView, dataOffset: number): Boundary | undefined {\n    if (dataOffset >= data.byteLength) {\n        throw new ParseError('dataOffset past end of DataView.');\n    }\n\n    const start = dataOffset;\n\n    // expected CR LF\n    if (!isCRLF(data, dataOffset)) {\n        return undefined;\n    }\n\n    // expecting '-' '-'\n    if (!isDoubleHyphen(data, dataOffset + 2)) {\n        return undefined;\n    }\n\n    // CR LF '-' '-'\n    dataOffset += 4;\n\n    for (let i = 0; i < boundary.length; ++i) {\n        if (i >= data.byteLength) {\n            return undefined; // we've hit the end of the data\n        }\n\n        if (boundary[i] !== data.getUint8(dataOffset + i)) {\n            return undefined; // does not match boundary\n        }\n    }\n\n    dataOffset += boundary.length;\n\n    let isLast: boolean;\n\n    if (isDoubleHyphen(data, dataOffset)) {\n        isLast = true;\n        dataOffset += 2;\n\n        if (dataOffset + 2 !== data.byteLength) {\n            // This means we've hit the last boundary\n            // TODO: not sure what we're supposed to do\n        }\n    }\n    else {\n        isLast = false;\n\n        if (isCRLF(data, dataOffset)) {\n            dataOffset += 2;\n        }\n        else {\n            // According to https://www.rfc-editor.org/rfc/rfc2046#section-5.1.1\n            // Any content after the boundary on a line should be ignored.\n            throw new Error('TODO: we should consume to the next CRLF here');\n        }\n    }\n\n    return {\n        start: start,\n        end: dataOffset,\n        length: dataOffset - start,\n        isLast: isLast\n    };\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA,eAAuC;AACvC,gBAA2B;AAiBpB,6BAA6B,UAAoB,MAA4B;AAChF,MAAI,SAAS,UAAU,GAAG;AACtB,UAAM,IAAI,qBAAW;AAAA;AAGzB,QAAM,MAAkB;AAIxB,WAAS,IAAI,GAAG,IAAI,KAAK,cAAa;AAClC,UAAM,UAAU,cAAc,UAAU,MAAM;AAE9C,QAAI,SAAS;AACT,UAAI,KAAK;AACT,WAAK,QAAQ;AAAA,WAEZ;AACD,QAAE;AAAA;AAAA;AAIV,SAAO;AAAA;AAGJ,uBAAuB,UAAoB,MAAgB,YAA0C;AACxG,MAAI,cAAc,KAAK,YAAY;AAC/B,UAAM,IAAI,qBAAW;AAAA;AAGzB,QAAM,QAAQ;AAGd,MAAI,CAAC,qBAAO,MAAM,aAAa;AAC3B,WAAO;AAAA;AAIX,MAAI,CAAC,6BAAe,MAAM,aAAa,IAAI;AACvC,WAAO;AAAA;AAIX,gBAAc;AAEd,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,EAAE,GAAG;AACtC,QAAI,KAAK,KAAK,YAAY;AACtB,aAAO;AAAA;AAGX,QAAI,SAAS,OAAO,KAAK,SAAS,aAAa,IAAI;AAC/C,aAAO;AAAA;AAAA;AAIf,gBAAc,SAAS;AAEvB,MAAI;AAEJ,MAAI,6BAAe,MAAM,aAAa;AAClC,aAAS;AACT,kBAAc;AAEd,QAAI,aAAa,MAAM,KAAK,YAAY;AAAA;AAAA,SAKvC;AACD,aAAS;AAET,QAAI,qBAAO,MAAM,aAAa;AAC1B,oBAAc;AAAA,WAEb;AAGD,YAAM,IAAI,MAAM;AAAA;AAAA;AAIxB,SAAO;AAAA,IACH;AAAA,IACA,KAAK;AAAA,IACL,QAAQ,aAAa;AAAA,IACrB;AAAA;AAAA;",
  "names": []
}
