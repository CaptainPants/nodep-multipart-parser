{
  "version": 3,
  "sources": ["../../../../src/multipart/internal/util.ts"],
  "sourcesContent": ["import { ParseError } from \"../..\";\n\nexport const chars = {\n    cr: 13,\n    lf: 10,\n    hyphen: '-'.charCodeAt(0)\n} as const;\n\nexport function isDoubleCRLF(data: DataView, offset: number) {\n    if (offset + 3 >= data.byteLength) {\n        return false;\n    }\n\n    return data.getUint8(offset) == chars.cr &&\n        data.getUint8(offset + 1) == chars.lf &&\n        data.getUint8(offset + 2) == chars.cr &&\n        data.getUint8(offset + 3) == chars.lf;\n}\n\nexport function isCRLF(data: DataView, offset: number) {\n    if (offset + 1 >= data.byteLength) {\n        return false;\n    }\n\n    const first = data.getUint8(offset);\n    const second = data.getUint8(offset + 1);\n    return first == chars.cr && second == chars.lf;\n}\n\nexport function isDoubleHyphen(data: DataView, offset: number) {\n    if (offset + 1 >= data.byteLength) {\n        return false;\n    }\n\n    const first = data.getUint8(offset);\n    const second = data.getUint8(offset + 1);\n    return first == chars.hyphen && second == chars.hyphen;\n}\n\n\n/**\n  * ASCII/ISO-8859-1 (should be a subset)\n  */\nexport function getCharCodesForString(str: string) {\n    const res: number[] = [];\n    for (let i = 0; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n        if (code > 255) {\n            throw new ParseError('Boundary characters must be ISO-8859-1 values from 0-255.');\n        }\n        res.push(code);\n    }\n    return res;\n}\n\nexport function getAsciiStringFromDataView(dataview: DataView) {\n    const numbers: number[] = [];\n\n    for (let i = 0; i < dataview.byteLength; ++i) {\n        const current = dataview.getUint8(i);\n        numbers.push(current);\n    }\n\n    return String.fromCharCode.apply(null, numbers);\n}\n\nexport function asciiToDataViewForTesting(content: string) {\n    content = content.replace(/\\n/g, '\\r\\n'); // javascript `` literal newlines are \\n by itself\n\n    const temp: number[] = [];\n    for (let i = 0; i < content.length; ++i) {\n        temp[i] = content.charCodeAt(i);\n    }\n\n    return new DataView(new Uint8Array(temp).buffer);\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAA2B;AAEpB,MAAM,QAAQ;AAAA,EACjB,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,QAAQ,IAAI,WAAW;AAAA;AAGpB,sBAAsB,MAAgB,QAAgB;AACzD,MAAI,SAAS,KAAK,KAAK,YAAY;AAC/B,WAAO;AAAA;AAGX,SAAO,KAAK,SAAS,WAAW,MAAM,MAClC,KAAK,SAAS,SAAS,MAAM,MAAM,MACnC,KAAK,SAAS,SAAS,MAAM,MAAM,MACnC,KAAK,SAAS,SAAS,MAAM,MAAM;AAAA;AAGpC,gBAAgB,MAAgB,QAAgB;AACnD,MAAI,SAAS,KAAK,KAAK,YAAY;AAC/B,WAAO;AAAA;AAGX,QAAM,QAAQ,KAAK,SAAS;AAC5B,QAAM,SAAS,KAAK,SAAS,SAAS;AACtC,SAAO,SAAS,MAAM,MAAM,UAAU,MAAM;AAAA;AAGzC,wBAAwB,MAAgB,QAAgB;AAC3D,MAAI,SAAS,KAAK,KAAK,YAAY;AAC/B,WAAO;AAAA;AAGX,QAAM,QAAQ,KAAK,SAAS;AAC5B,QAAM,SAAS,KAAK,SAAS,SAAS;AACtC,SAAO,SAAS,MAAM,UAAU,UAAU,MAAM;AAAA;AAO7C,+BAA+B,KAAa;AAC/C,QAAM,MAAgB;AACtB,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,EAAE,GAAG;AACjC,UAAM,OAAO,IAAI,WAAW;AAC5B,QAAI,OAAO,KAAK;AACZ,YAAM,IAAI,oBAAW;AAAA;AAEzB,QAAI,KAAK;AAAA;AAEb,SAAO;AAAA;AAGJ,oCAAoC,UAAoB;AAC3D,QAAM,UAAoB;AAE1B,WAAS,IAAI,GAAG,IAAI,SAAS,YAAY,EAAE,GAAG;AAC1C,UAAM,UAAU,SAAS,SAAS;AAClC,YAAQ,KAAK;AAAA;AAGjB,SAAO,OAAO,aAAa,MAAM,MAAM;AAAA;AAGpC,mCAAmC,SAAiB;AACvD,YAAU,QAAQ,QAAQ,OAAO;AAEjC,QAAM,OAAiB;AACvB,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACrC,SAAK,KAAK,QAAQ,WAAW;AAAA;AAGjC,SAAO,IAAI,SAAS,IAAI,WAAW,MAAM;AAAA;",
  "names": []
}
