{
  "version": 3,
  "sources": ["../../../src/multipart/MultipartParser.ts"],
  "sourcesContent": ["import { ParseError } from '../ParseError';\nimport { parseHeaders, ContentType, ContentDisposition, parseContentType, parseContentDisposition } from '../headers';\nimport { findBoundarySeparatedParts, getAsciiStringFromDataView, getCharCodesForString, isDoubleCRLF } from './internal';\n\nexport interface MultipartResult {\n    parts: MultipartPart[];\n}\n\nexport interface MultipartPart {\n    headers: { name: string; value: string }[];\n    content: DataView;\n    contentType: ContentType | undefined;\n    contentDisposition: ContentDisposition | undefined;\n}\n\n/**\n  * Parses a multipart body into usable segments.\n  * https://www.rfc-editor.org/rfc/rfc2046#section-5.1.7\n  */\nexport class MultipartParser {\n    parseDataView(\n        boundary: string,\n        data: DataView\n    ): MultipartResult {\n        const parts: MultipartPart[] = [];\n\n        // Get the equivelent ASCII values for the boundary string\n        const boundaryCodes = getCharCodesForString(boundary);\n\n        // Using the boundary string, break the data DataView into segments\n        const partViews = findBoundarySeparatedParts(boundaryCodes, data);\n\n        for (let i = 0; i < partViews.length; ++i) {\n            const current = partViews[i];\n\n            // Each part has a header and a body, this splits them into a string for headers \n            // and a DataView for the body\n            const { headers: headerString, content } = splitPartHeaderAndBody(current);\n\n            const headersResult = parseHeaders({ headerString: headerString });\n\n            const contentTypeIndex = headersResult.headers.findIndex(x => x.name == 'content-type');\n            const contentDispositionIndex = headersResult.headers.findIndex(x => x.name == 'content-disposition');\n\n            const contentType = contentTypeIndex >= 0 ? parseContentType(headersResult.headers[contentTypeIndex].value)\n                : undefined;\n            const contentDisposition = contentDispositionIndex >= 0 ? parseContentDisposition(headersResult.headers[contentDispositionIndex].value)\n                : undefined;\n\n            parts.push({\n                headers: headersResult.headers,\n                content: content,\n                contentType: contentType,\n                contentDisposition: contentDisposition\n            });\n        }\n\n        return {\n            parts: parts\n        };\n    }\n}\n\n/**\n  * Find the first double CRLF in the data view. The section before is the headers, the \n  * section after is the body. Converts the headers to string.\n  */\nfunction splitPartHeaderAndBody(dataview: DataView): { headers: string, content: DataView } {\n    for (let i = 0; i < dataview.byteLength; ++i) {\n        if (isDoubleCRLF(dataview, i)) {\n            const headerPart = new DataView(\n                dataview.buffer,\n                dataview.byteOffset,\n                i\n            );\n\n            const headerString = getAsciiStringFromDataView(headerPart);\n\n            const startOfBodyPart = i + 4;\n            const lengthOfBodyPart = dataview.byteLength - startOfBodyPart;\n\n            const bodyPart = new DataView(\n                dataview.buffer,\n                dataview.byteOffset + startOfBodyPart,\n                lengthOfBodyPart\n            );\n\n            return { headers: headerString, content: bodyPart };\n        }\n    }\n\n    throw new ParseError('No CR LF CR LF sequence found');\n}\n\nexport const __testing = process.env.NODE_ENV == 'test' ? {\n    splitPartHeaderAndBody\n} : void 0;"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA,wBAA2B;AAC3B,qBAAyG;AACzG,sBAA4G;AAiBrG,sBAAsB;AAAA,EACzB,cACI,UACA,MACe;AACf,UAAM,QAAyB;AAG/B,UAAM,gBAAgB,2CAAsB;AAG5C,UAAM,YAAY,gDAA2B,eAAe;AAE5D,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,EAAE,GAAG;AACvC,YAAM,UAAU,UAAU;AAI1B,YAAM,EAAE,SAAS,cAAc,YAAY,uBAAuB;AAElE,YAAM,gBAAgB,iCAAa,EAAE;AAErC,YAAM,mBAAmB,cAAc,QAAQ,UAAU,OAAK,EAAE,QAAQ;AACxE,YAAM,0BAA0B,cAAc,QAAQ,UAAU,OAAK,EAAE,QAAQ;AAE/E,YAAM,cAAc,oBAAoB,IAAI,qCAAiB,cAAc,QAAQ,kBAAkB,SAC/F;AACN,YAAM,qBAAqB,2BAA2B,IAAI,4CAAwB,cAAc,QAAQ,yBAAyB,SAC3H;AAEN,YAAM,KAAK;AAAA,QACP,SAAS,cAAc;AAAA,QACvB;AAAA,QACA;AAAA,QACA;AAAA;AAAA;AAIR,WAAO;AAAA,MACH;AAAA;AAAA;AAAA;AASZ,gCAAgC,UAA4D;AACxF,WAAS,IAAI,GAAG,IAAI,SAAS,YAAY,EAAE,GAAG;AAC1C,QAAI,kCAAa,UAAU,IAAI;AAC3B,YAAM,aAAa,IAAI,SACnB,SAAS,QACT,SAAS,YACT;AAGJ,YAAM,eAAe,gDAA2B;AAEhD,YAAM,kBAAkB,IAAI;AAC5B,YAAM,mBAAmB,SAAS,aAAa;AAE/C,YAAM,WAAW,IAAI,SACjB,SAAS,QACT,SAAS,aAAa,iBACtB;AAGJ,aAAO,EAAE,SAAS,cAAc,SAAS;AAAA;AAAA;AAIjD,QAAM,IAAI,6BAAW;AAAA;AAGlB,MAAM,YAAY,QAAQ,IAAI,YAAY,SAAS;AAAA,EACtD;AAAA,IACA;",
  "names": []
}
