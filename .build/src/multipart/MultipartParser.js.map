{
  "version": 3,
  "sources": ["../../../src/multipart/MultipartParser.ts"],
  "sourcesContent": ["import { ParseError } from '..';\nimport { parseHeaders } from '../headers';\nimport { findBoundaryOffsets, getAsciiStringFromDataView, getCharCodesForString, isDoubleCRLF } from './internal';\n\n// https://www.rfc-editor.org/rfc/rfc2046#section-5.1.7\n\nexport interface MultipartResult {\n    parts: MultipartPart[];\n}\n\nexport interface MultipartPart {\n    headers: { name: string; value: string }[];\n    content: DataView;\n}\n\nexport class MultipartParser {\n    parse(\n        boundary: string,\n        data: DataView\n    ): MultipartResult {\n        const parts: MultipartPart[] = [];\n\n        // Get the equivelent ASCII values for the boundary string\n        const boundaryCodes = getCharCodesForString(boundary);\n\n        // Using the boundary string, break the data DataView into segments\n        const partViews = findParts(boundaryCodes, data);\n\n        for (let i = 0; i < partViews.length; ++i) {\n            const current = partViews[i];\n\n            // Each part has a header and a body, this splits them into a string for headers \n            // and a DataView for the body\n            const { headers: headerString, content } = splitPartHeaderAndBody(current);\n\n            const headersResult = parseHeaders({ headerString: headerString });\n\n            parts.push({\n                headers: headersResult.headers,\n                content: content\n            });\n        }\n\n        return {\n            parts: parts\n        };\n    }\n}\n\nfunction splitPartHeaderAndBody(dataview: DataView): { headers: string, content: DataView } {\n    for (let i = 0; i < dataview.byteLength; ++i) {\n        if (isDoubleCRLF(dataview, i)) {\n            const headerPart = new DataView(\n                dataview.buffer,\n                dataview.byteOffset,\n                i\n            );\n\n            const headerString = getAsciiStringFromDataView(headerPart);\n\n            const startOfBodyPart = i + 4;\n            const lengthOfBodyPart = dataview.byteLength - startOfBodyPart;\n\n            const bodyPart = new DataView(\n                dataview.buffer,\n                dataview.byteOffset + startOfBodyPart,\n                lengthOfBodyPart\n            );\n\n            return { headers: headerString, content: bodyPart };\n        }\n    }\n\n    throw new ParseError('No CR LF CR LF sequence found');\n}\n\nfunction findParts(boundaryCodes: number[], data: DataView): DataView[] {\n    const boundaryOffsets = findBoundaryOffsets(boundaryCodes, data);\n\n    if (boundaryOffsets.length == 0) {\n        return [];\n    }\n\n    const partViews: DataView[] = [];\n\n    for (let i = 1; i < boundaryOffsets.length; ++i) {\n        const startOffset = boundaryOffsets[i - 1];\n        const endOffset = boundaryOffsets[i];\n\n        const start = startOffset.end;\n        const end = endOffset.start;\n\n        const len = end - start;\n\n        const partView = new DataView(data.buffer, data.byteOffset + start, len);\n\n        partViews.push(partView);\n    }\n\n    return partViews;\n}\n\nexport const __testing = process.env.NODE_ENV == 'test' ? {\n    splitPartHeaderAndBody,\n    findParts\n} : void 0;"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA,eAA2B;AAC3B,qBAA6B;AAC7B,sBAAqG;AAa9F,sBAAsB;AAAA,EACzB,MACI,UACA,MACe;AACf,UAAM,QAAyB;AAG/B,UAAM,gBAAgB,2CAAsB;AAG5C,UAAM,YAAY,UAAU,eAAe;AAE3C,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,EAAE,GAAG;AACvC,YAAM,UAAU,UAAU;AAI1B,YAAM,EAAE,SAAS,cAAc,YAAY,uBAAuB;AAElE,YAAM,gBAAgB,iCAAa,EAAE;AAErC,YAAM,KAAK;AAAA,QACP,SAAS,cAAc;AAAA,QACvB;AAAA;AAAA;AAIR,WAAO;AAAA,MACH;AAAA;AAAA;AAAA;AAKZ,gCAAgC,UAA4D;AACxF,WAAS,IAAI,GAAG,IAAI,SAAS,YAAY,EAAE,GAAG;AAC1C,QAAI,kCAAa,UAAU,IAAI;AAC3B,YAAM,aAAa,IAAI,SACnB,SAAS,QACT,SAAS,YACT;AAGJ,YAAM,eAAe,gDAA2B;AAEhD,YAAM,kBAAkB,IAAI;AAC5B,YAAM,mBAAmB,SAAS,aAAa;AAE/C,YAAM,WAAW,IAAI,SACjB,SAAS,QACT,SAAS,aAAa,iBACtB;AAGJ,aAAO,EAAE,SAAS,cAAc,SAAS;AAAA;AAAA;AAIjD,QAAM,IAAI,oBAAW;AAAA;AAGzB,mBAAmB,eAAyB,MAA4B;AACpE,QAAM,kBAAkB,yCAAoB,eAAe;AAE3D,MAAI,gBAAgB,UAAU,GAAG;AAC7B,WAAO;AAAA;AAGX,QAAM,YAAwB;AAE9B,WAAS,IAAI,GAAG,IAAI,gBAAgB,QAAQ,EAAE,GAAG;AAC7C,UAAM,cAAc,gBAAgB,IAAI;AACxC,UAAM,YAAY,gBAAgB;AAElC,UAAM,QAAQ,YAAY;AAC1B,UAAM,MAAM,UAAU;AAEtB,UAAM,MAAM,MAAM;AAElB,UAAM,WAAW,IAAI,SAAS,KAAK,QAAQ,KAAK,aAAa,OAAO;AAEpE,cAAU,KAAK;AAAA;AAGnB,SAAO;AAAA;AAGJ,MAAM,YAAY,QAAQ,IAAI,YAAY,SAAS;AAAA,EACtD;AAAA,EACA;AAAA,IACA;",
  "names": []
}
